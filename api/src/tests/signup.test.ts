import request from 'supertest';
import { ERROR_MESSAGE, SUCESS_MESSAGE } from '../constatnts/messages';
import app from '../server';
import User from '../modals/userModal';

// Mocking the User model
jest.mock('../models/User');

describe('POST /signup', () => {
  const validUser = {
    username: 'testuser',
    email: 'testuser@example.com',
    password: 'hashedpassword', // Replace with the actual hashed password for real tests
  };

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should return 400 if any required field is missing', async () => {
    const response = await request(app).post('/signup').send({ username: 'testuser', email: '' });
    expect(response.status).toBe(400);
    expect(response.body.message).toBe(ERROR_MESSAGE.SIGN_UP[400]);
  });

  it('should return 401 if the email is already in use', async () => {
    (User.findOne as jest.Mock).mockResolvedValue(validUser);
    const response = await request(app)
      .post('/signup')
      .send(validUser);
    expect(response.status).toBe(401);
    expect(response.body.message).toBe(ERROR_MESSAGE.SIGN_UP[401]);
  });

  it('should return 201 and success message if registration is successful', async () => {
    (User.findOne as jest.Mock).mockResolvedValue(null); // No existing user
    (User.prototype.save as jest.Mock).mockResolvedValue(validUser); // Mock save method

    const response = await request(app)
      .post('/signup')
      .send(validUser);
    expect(response.status).toBe(201);
    expect(response.body.message).toBe(SUCESS_MESSAGE.SIGN_UP[201]);
    expect(response.body.user).toEqual({
      id: expect.any(String), // _id is generated by MongoDB, so we just check it exists
      username: validUser.username,
      email: validUser.email,
    });
  });

  it('should return 500 if there is a server error', async () => {
    (User.findOne as jest.Mock).mockRejectedValue(new Error('Server error'));
    const response = await request(app)
      .post('/signup')
      .send(validUser);
    expect(response.status).toBe(500);
    expect(response.body.message).toBe(ERROR_MESSAGE.COMMON_ERROR[500]);
  });
});
